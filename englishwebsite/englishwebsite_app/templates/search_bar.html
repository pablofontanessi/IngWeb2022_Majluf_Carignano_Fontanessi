{% load static %}

<head>
    <link href="{% static 'css/search_bar.css' %}" rel="stylesheet" type="text/css" />
    <script src="//code.jquery.com/jquery-1.10.2.js"></script>
    <script src="//code.jquery.com/ui/1.11.4/jquery-ui.js"></script>
    <script src="//jqueryui.com/jquery-wp-content/themes/jquery/js/plugins.js"></script>
    <script src="//jqueryui.com/jquery-wp-content/themes/jquery/js/main.js"></script>
    <link rel="stylesheet" href="//code.jquery.com/ui/1.11.4/themes/smoothness/jquery-ui.css">
</head>

<body>
    <form method="get" action="/search/" class="autocomplete-me">
        <div style="padding: 0px;">
            <div class="row">
                <div class="col-md-10" style="padding:0px">
                    <input type="text" class="form-control" id="id_q" name="q">
                </div>
                <div class="col-md-2" style="padding:0px">
                    <input class="btn btn-success" type="submit" value="Buscar!">
                </div>
            </div>
        </div>
    </form>

    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js"></script>
    <script type="text/javascript">
    // In a perfect world, this would be its own library file that got included
    // on the page and only the ``$(document).ready(...)`` below would be present.
    // But this is an example.
    var Autocomplete = function(options) {
        this.form_selector = options.form_selector
        this.url = options.url || '/search/autocomplete/'
        this.delay = parseInt(options.delay || 300)
        this.minimum_length = parseInt(options.minimum_length || 3)
        this.form_elem = null
        this.query_box = null
    }

    Autocomplete.prototype.setup = function() {
        var self = this

        this.form_elem = $(this.form_selector)
        this.query_box = this.form_elem.find('input[name=q]')

        // Watch the input box.
        this.query_box.on('keyup', function() {
        var query = self.query_box.val()

        if(query.length < self.minimum_length) {
            return false
        }

        self.fetch(query)
        })

        // On selecting a result, populate the search field.
        this.form_elem.on('click', '.ac-result', function(ev) {
        self.query_box.val($(this).text())
        $('.ac-results').remove()
        return false
        })
    }

    Autocomplete.prototype.fetch = function(query) {
        var self = this

        $.ajax({
        url: this.url
        , data: {
            'q': query
        }
        , success: function(data) {
            self.show_results(data)
        }
        })
    }

    Autocomplete.prototype.show_results = function(data) {
        // Remove any existing results.
        $('.ac-results').remove()

        var results = data.results || []
        var results_wrapper = $('<div class="ac-results" style="cursor: pointer;background-color: #fff;padding: 2 solid #d4d4d4;border-radius: 5px;text-align: left;padding-left: 10;"></div>')
        var base_elem = $('<div class="result-wrapper"><a href="#" style="color:black" class="ac-result"></a></div>')

        if(results.length > 0) {
        for(var res_offset in results) {
            var elem = base_elem.clone()
            // Don't use .html(...) here, as you open yourself to XSS.
            // Really, you should use some form of templating.
            elem.find('.ac-result').text(results[res_offset])
            results_wrapper.append(elem)
        }
        }
        else {
        var elem = base_elem.clone()
        elem.text("No existe un resultado con ese nombre.")
        results_wrapper.append(elem)
        }

        this.query_box.after(results_wrapper)
    }

    $(document).ready(function() {
        window.autocomplete = new Autocomplete({
        form_selector: '.autocomplete-me'
        })
        window.autocomplete.setup()
    })
</script>

</body>
